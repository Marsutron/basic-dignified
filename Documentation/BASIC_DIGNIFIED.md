# Basic Dignified    The **Basic Dignified Converter** is the heart of the suite. It reads a text file containing the **Dignified** code and write back **classic** Basic in **ASCII** and/or **binary** format (the binary output needs a **tokenizer** module).    **[Features and usage](#Features-and-usage)**  **[Configurable arguments](#Configurable-arguments)**      ## Features and usage    To run **Basic Dignified**, open a terminal window on its folder and type:  `python msxbadig.py <DIGNIFIED_CODE> [CLASSIC_CODE] [arguments]`  > `python` may be omitted or be called `python3` depending on your installation.    >From now on, when showing code, usually the first excerpt is **Dignified** code, followed by the **program call** with the relevant **arguments** and the **classic** Basic output.  >For the sake of clarity only arguments relevant to the current topic will be shown on the program call.    Unlike traditional Basics, instructions, functions and variables in the Dignified version must be **separated** by spaces from alphanumeric characters as in modern languages. The **MSX Syntax Highlight** will reflect this and there are settings to conform the spacing when the conversion is made.  Dignified code should always **end** with a **blank line**.  Code indentation is encouraged to help readability, **indentation** can be done with **TABS** or **SPACES**. The use os SPACES is highly **recommended**. When indenting with TABS use the argument `-tl` to define the TAB **length** in spaces for better indication of **error reporting**.  All blank lines are **removed** except the ones inside **regular** block comments `''`. All spaces are **stripped** from the **start** and **end** of a line.  Some classic Basics are confused when **concatenating** certain **characters and words** so the Dignified code will try to accommodate for that by **separating** some of them. On  **MSX Basic**, `x` and `or` are kept separated to avoid an `xor` by mistake. Also, **hexadecimal** numbers followed by words beginning with `a` to `f` are kept separated to avoid mistakes.  Duplicated `:` are removed.    ### Structure:     - **Labels**  are used to direct the code flow, since the **Dignified** code does not have line numbers.  Labels are created using curly brackets `{like_this}` and can be used **alone** on a line to receive the code flow or on a **branching** (jump) instruction to direct the flow to the corresponding **line label**. They can only have **letters**, **numbers** and **underscore** and they cannot be only numbers or begin with a number. `{@}` is a special label that points to its **own line**.  A special kind of label called **loop label** can be used to create a concise **closed loop**. It is opened with `label{` and closed with `}`. The **opening** label works like any regular label and the **closing** one will send the flow back to the opening label. Loop labels can be **nested**.  You can exit a loop label with the `exit` command, it will send the flow to the **next line** after the closing label.  A **visualization** of the program flow can be generated by using the `-lbr` argument. At the end of each line a `<` or a `>` (depending on if the flow is coming or exiting this line) followed by its **label name** will appear as a comment. A **loop label exit** will be given a `*` and self-referencing line a `>@`  A **summary** of the line number **associations** can be generated by using the `-lnr` argument.  It will be saved to a file but can be logged to the console using the `-prr` (print report) argument.  	>Labels not following the **naming convention**, **duplicated** line labels, labels branching to **inexistent** line labels and loop labels **not closed** will generate an error and stop the conversion. Labels with illegal characters are **highlighted** when using the **MSX Syntax Highlight**.  	>**Lines** starting with **numbers** will be **removed**, the highlight will show a warning.    	```BASIC      {start}      print "press A to toggle"      if inkey$ <> "A" then goto {@}      loop{          a$ = inkey$          print "press B to exit"          if a$ = "A" then goto {start}          if a$ = "B" then exit      }      end  	```  	`badig.py labels.dmx`  	```BASIC      10 PRINT "press A to toggle"      20 IF INKEY$<>"A" THEN GOTO 20      30 A$=INKEY$      40 PRINT "press B to exit"      50 IF A$="A" THEN GOTO 10      60 IF A$="B" THEN GOTO 80      70 GOTO 30      80 END  	```    	Flow visualization with  `badig.py labels.dmx -lbr`  	```BASIC      10 PRINT "press A to toggle" '<start      20 IF INKEY$<>"A" THEN GOTO 20 '>@      30 A$=INKEY$ '<loop      40 PRINT "press B to exit"      50 IF A$="A" THEN GOTO 10 '>start      60 IF A$="B" THEN GOTO 80 '*loop      70 GOTO 30 '>loop      80 END  	```    	Report generated with  `badig.py labels.dmx -lnr`  	```  	8 lines generated.  	(Classic - Dignified)  	10 - 2  	20 - 3  	30 - 5  	40 - 6  	50 - 7  	60 - 8  	70 - 9  	80 - 10  	```    - **Defines**  create aliases on the code that are replaced when the conversion is made.  They are defined with `define [name][content]` where the `content` will replace the `[name]`. Several can be defined on the same line, separated by commas: `define [name1][content1],[name2][content2],[name3][content3]`.  A define `name` can only have **letters**, **numbers** and **underscore** and they cannot be only numbers or begin with a number.  A **define variable** can be created using `[]` inside a `content` definition. It will be substituted by an `argument` that must be placed between **parenthesis** `()` after the `[name]` is used on the code. If there is content inside the brackets of the **define variable** it will be used as **default** if no argument is given.  For instance, using `DEFINE [pk][poke 100,[10]]`, a subsequent `[pk](30)` will be replaced by `poke 100,30`; `[pk]` alone will be replaced by `poke 100,10`.  The **MSX module** has a `[?](x,y)` **built in** define that becomes `LOCATEx,y:PRINT`.  Defines can be used as variables for other defines.  	>Duplicated **defines** will give an error and stop the conversion.    	```BASIC      define [ifa][if a$ = ],[enter][chr$(13)]      define [pause][if inkey$<>[" "] goto {@}]        [ifa]"1" then print "one"      [ifa]"2" then print "two"      [?](10,10)"ten by ten"      [pause]([enter])  	```  	`badig.py defines.dmx`  	```BASIC      10 IF A$="1" THEN PRINT "one"      20 IF A$="2" THEN PRINT "two"      30 LOCATE 10,10:? "ten by ten"      40 IF INKEY$<>CHR$(13)GOTO 40  	```    - **Long named variables**  can be used on the Dignified code.  They can only have **letters**, **numbers** and **underscore**, they cannot be only numbers, begin with a number or have less than 3 characters. Long named variabels are **case insensitive**.  When converted they are replaced by an associated standard two letter variables. They are assigned on a **descending** order from `ZZ` to `AA` and **single letters** and **letter+number** are never used. Each long name is assigned to a short name independent of **type**, so if `variable1`  becomes `XX` so will `variable1$` will become `XX$`.  An **explicit** assignment between a long and a short name can be **forced** using the `declare` instruction: `declare variable:va` will assign `VA` to `variable`. Several declares can be given on the same line, separated by commas: `declare variable1:v1,variable2:v2,variable3:v3`.  A `declare` can also be used to **reserve** short named variables: `declare zz,xv,cd` will **prevent** those letters from being assigned to long named variables. You cannot reserve **one letter** variables (buy you also don't need to).  As variables are assigned independent of type, explicit type character (`$%!#`) cannot be used on a `declare` line.  **Reserved** Basic commands should not be declared as variables as they might be assigned and converted.  **Traditional** one and two letters variables can be used normally alongside long names ones, just be aware that the letters at the end of the alphabet are being **used up** and they may clash with the **hard coded** ones. Warnings and/or errors will be given in case of clonflicts.  A `~` before the variable name will keep its original long name. Some Basics accepts long names, **discarding** all characters after the **second** one. `~` cannot be used on a short named variable.  Hardcoded short named variables are not used by subsequent long named substitutions.  A **summary** of the long and short name **associations** can be generated by using the `-var` argument.  It will be saved to a file but can be logged to the console using the `-prr` (print report) argument.  	>The conversion (and the **MSX Syntax Highlight**) will catch illegal variables when declaring. Repeated declarations will cause an error. A warning will be given if **hardcoded** short named variables are **already** assigned and if a short name hard coded was already used by **substitution**.  	```BASIC      declare food:fd, drink:dk      if food$ = "cake" and drink = 3 then end      result$ = "belly full"      ~sleep = 10      print result$  	```  	`badig.py vars.dmx`  	```BASIC      10 IF FD$="cake" AND DK=3 THEN END      20 ZZ$="belly full"      30 SLEEP=10      40 PRINT ZZ$  	```  	Report generated with  `badig.py vars.dmx -var`  	```  	3 variables assigned  	zz:result  	fd:food  	dk:drink  	```    - **Proto-functions**  emulate the use of modern function definition and calls.  They are **defined** with `func .functionName(arg1, arg2, etc)` and must end with `ret`. Their names can only have **letters**, **numbers** and **underscore** and they cannot be only numbers or begin with a number.  The arguments can have **default values** as in `func .function(arg$="teste")` and `ret` can have **return variables** like `ret arg1, arg2, etc`.  `ret` must be at the start of a line but you can use a `:` on the line above to make it part of that line (see **line breaking**).  The functions are **called** with `.functionName(arg1, arg2, etc)` and can be **assigned** to variables like `var1, var2 = .functionName(args)`. They can be separated by `:` as usual and can also come after a `THEN` or `ELSE`: `if a=1 then .doStuff() else .dontDoStuff()`.  The number of **assigned** variables and **return** variables must match and be explicitly given, except for an argument with a **default value**, in this case the default will be used if an **empty space** is passed on that position.  There can be only **one** `ret`, it will signal the **end** of the function definition. A regular `RETURN`, however, can be used inside the function to return from a **different** point. This `RETURN` cannot take variables.  Obviously, there are no **local variables** on most of the **classical** Basics (which can limit the usefulness of the proto-functions) but this can be simulated by using **unique named** variables inside the functions. Proto-function can also be useful to apply different **results** to different **variables** at different **points** in the code.  A function **call** is a `GOSUB` to a function **definition** with the variables assigned before and after it accordingly.  If the arguments or return variable are the **same** between function calls and definitions, they will not be equated on the conversion to avoid **unnecessary repetition** like `A$=A$`.  As with labels, proto-functions will have their flow visualized with the `-lbr` argument.  Different from a normal function, `func` definitions will **not deviate** the **code flow** from itself so they must be placed at an **unreachable** point in the code.  	>Most **classic** Basic are **very slow**, specially the `GOSUB` instruction, so keep that in mind when abusing proto-functions.    	```BASIC      letter$ = .upper("a")      print letter$      end      func .upper(up$)          ch = asc(up$) - 32      ret chr$(ch)  	```  	`badig.py func.dmx`  	```BASIC      10 UP$="a":GOSUB 40:ZZ$=CHR$(CH)      20 PRINT ZZ$      30 END      40 CH=ASC(UP$)-32      50 RETURN  	```    - **Line separation**  is possible with Basic Dignified using `:` or `_` at the **end** or **start** of a line. When converted, the lines are **joined** to form a single one.  **Colons** `:` can be used at the **end** of a line to join the **next one** or at the **beginning** of a line to join it to the **previous one** and are retained in the converted code. Their function is the same as on some classic Basics, separating different instructions.  **Underscores** `_` can only be used at the end of a line and they are **deleted** when the line is joined. They are useful to **break instructions** like `IF THEN ELSE` or anything that must form a single, unbroken, command on the converted code. They must be **separated** from the **last character** if it is a word character and they do not work at the end of **comments** or **open quotes**.  **Quotes** can be **joined** simply by stringing them, even across different lines, like `PRINT "Hello " "word"`  `endif`s can be used to mark the end of a multi-line `IF` statement but are for **cosmetical** or **organisational** purpose only, they will be **removed** without processing. An `IF` block is better defined by **indentation**, Python style.  	>Lines starting with a number after an **underscore** `_` break will be **preserved** but the ones after a **colon** `:` break will be **removed**.    	```BASIC  	if a$ = "" then _  	    for f = 1 to 10:  	        [?](1,1) f:  	    next  	    :[?](1,3) "All "  	              "done."  	    :end  	endif  	```  	`badig.py lines.dmx`  	```BASIC      10 IF A$="" THEN FOR F=1 TO 10:LOCATE 1,1:? F:NEXT:LOCATE 1,3:? "All done.":END  	```    - **Exclusive comments**  are comments **stripped** during the conversion, they are defined by `##`.  **Regular** `REM` or `'` comments are **kept**.  **Block comments** can also be used, they are **opened** and **closed** with `''` or `###`, the text inside the first one will be **kept** while the text inside the later will be **removed**.    	```BASIC      ## this will be removed      rem this will stay      ' this also will stay      ###      This will be removed      ###      ''      This will stay      ''  	```  	`badig.py rems.dmx`  	```BASIC      10 REM this will stay      20 ' this also will stay      30 'This will stay  	```  - **Line toggles**  tags parts of the code to be **removed** on **demand** when converted. They have the format `#name` where `name` can have **letters**, **numbers** and **underscore** and cannot be only numbers or begin with a number. They can be kept by simply using `keep #name1 #name2 #etc` on a line **before** them. `keep` can take **none**, **one** or **more** toggles on the same line, separated by spaces.  There are two **special** toggles, `#all` **keeps** everything and  `#none` **removes** everything. If using both, `#none` has the precedence.  Toggles are used at the **start** of a line (`#p print "Hello"`) or they can be **alone** to denote the **start** and **end** of a **block** to be removed, just like block comments. They can be **useful** to **debug** different code lines or sections without having to comment and uncomment them every time. Block toggles can be **nested** but cannot be **interleaved**.  	>A warning will be given if line toggles are not closed.    	```BASIC      keep #b      #a print "this will not be converted"      #b print "this will be converted"      print "this also will be converted"      #c      print "This will not be converted"      print "And neither will this"      #c  	```  	`badig.py toggles.dmx`  	```BASIC      10 PRINT "this will be converted"      20 PRINT "this also will be converted"  	```    - **Classic Basic ASCII characters**  are not supported by the default encoding of the `.bad` and `.asc` programs (`Western (Windows 1252)`). Their **representation** can be seen and used by opening an **ASCII** file **exported** from the computer/emulator and **copying/pasting** their symbols, but this is far from practical, a bit ugly and prone to problem.  By using `UTF-8` encoding on the `.bad` file, **unicode** characters similar to the classic ones can be used on the Dignified code and be **translated** to their **analogue** counterparts when converting. This allows for a much cleaner and accurate presentation.  The supported **unicode** characters for the **MSX ASCII** set are:  	```      ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»ÃãĨĩÕõŨũĲĳ¾∽◇‰¶§▂▚▆▔◾▇▎▞▊▕▉▨▧▼▲▶◀⧗⧓▘▗▝▖▒Δǂω█▄▌▐▀αβΓπΣσμτΦθΩδ∞φ∈∩≡±≥≤⌠⌡÷≈°∙‐√ⁿ²❚■☺☻♥♦♣♠·◘○◙♂♀♪♬☼┿┴┬┤├┼│─┌┐└┘╳╱╲╂      ```      They were choosen for their **similarities** with the MSX ones but the **actual shape** will depend on the **font used**.      >For extreme cases, the **MSX package** has a **TrueType MSX font** available.              ```BASIC      print "┌──────┐"      print "│SAVING│"      print "└──────┘"      ```      `badig.py transl.dmx -tr`      ```BASIC      10 PRINT "XWWWWWWY"      20 PRINT "VSAVINGV"      30 PRINT "ZWWWWWW["  	```    >When saving a Basic program as **ASCII** from **openMSX** (`save"file",a`) the text encode used is the `Western (Windows 1252)`. This is the format **Basic Dignified** uses to encode the `.asc` conversion and is the default encode for the `.bad` format as well. If **unicode translation** and special characters are used, the `.bad` format should be in the `UTF-8` format. The conversion will still generate a `Western (Windows 1252)` `.asc` file with the correct special characters translated to the **MSX ASCII** format.    - **Include**  is a command to **insert** an **external** Dignified file anywhere in the code.  `include "code.bad"` will insert the **contents** of `code.bad` exactly where the `include` was and can even have its **lines joined** with the main code by using `:` or `_` before or after the `include` command.  Included files have **separated** namespaces. **Rem toggles**, **functions**, **labels** and **defines** can have the same definition across the files **without conflict**.  **Long named** variables are also assigned **different short names** across includes however they cannot have the same **names** across included files and a **warning** will be given if the **same hardcoded** variables are used across includes.    	`include.dmx`  	```BASIC      print "This is the main file."      '      include "help.dmx"      '      print "This is the main file again."  	```  	`help.dmx`  	```BASIC      print "this is a helper code."      print "Saved on another file."  	```  	`badig.py include.dmx`  	```BASIC      10 PRINT "This is the main file."      20 '      30 PRINT "this is a helper code."      40 PRINT "Saved on another file."      50 '      60 PRINT "This is the main file again."  	```    - **True** and **false**  statements can be used with **numeric** variables, they will be converted to `-1` and `0` respectively and their variables can be treated as true **booleans** on `IF`s and with `NOT` operators.    	```BASIC      var_bool = true      condition = false      if condition then var_bool = not var_bool  	```  	`badig.py bool.dmx`  	```BASIC      10 ZZ=-1      20 ZY=0      30 IF ZY THEN ZZ=NOT ZZ  	```    - **Shorthand** and **compound**  arithmetic operators (`++`, `--`, `+=`, `-=`, `*=`, `/=`, `^=`) can be used and will be converted to **normal** classic Basic **operations**.    	```BASIC      var1++ :var2--      var3 += 20 :var4 -= 10  	```  	`badig.py operat.dmx`  	```BASIC      10 ZZ=ZZ+1:ZY=ZY-1      20 ZX=ZX+20:ZW=ZW-10  	```      ## Configurable arguments    **Configurations** to the behaviour of Basic Dignified can be **applied** on:    `code:` The **code itself** (in `\Modules\Settings\badig_settings.py`).  `.ini:` The **.ini file** (in `\Modules\Settings\badig.ini`).  `cmdl:` Through arguments on the **command line**.  `rmtg:` Using **remtags**.    Each method has a **priority** higher than the one before.    > See [below](#The-settings-environments) for a **detailed description** of each of them and an **explanation** of what are **remtags**.    > When not specified in the description below, **remtags** (`rmtg:`) are entered in `##BB:arguments=` with the same arguments as the **command line** (`cmdl:`).      - *Source file*  The Dignified code file to be read.  `Default:` `""`  `code:` `self.file_load = ['SOURCE_FILE']`  `.ini:` `source_file = [SOURCE_FILE]`  `cmdl:` `<SOURCE_FILE>`  `rmtg:` **none**    - *Destination file*  The classic Basic file to be saved.  `Default:` **none**  `code:` `self.file_save = ['DESTINATION_FILE']`  `.ini:` `destin_file = [DESTINATION_FILE]`  `cmdl:` `[DESTINATION_FILE]`  `rmtg:` `##BB:export_file=[DESTINATION_FILE]`  If no destination is given, the *source* name will be used with the appropriate extension.    - *System ID*  The classic system chosen to load information and modules.  `Default:` `msx`  `code:` `self.system_id = ['SYSTEM_ID']`  `.ini:` `system_id = [SYSTEM_ID]`  `cmdl:` `-id <SYSTEM_ID>`    - *TAB Length*  The number of spaces corresponding to a TAB on the code editor.  This is necessary for the correct positioning of error reports when indenting with TABs.  `Default:` `4`  `code:` `self.tab_lenght = [#]`  `.ini:` `tab_lenght = [#]`  `cmdl:` `-tl <#>`    - *Starting line number*  The number of the first line on the converted classic code.  `Default:` `10`  `code:` `self.line_start = [#]`  `.ini:` `line_start = [#]`  `cmdl:` `-ls <#>`    - *Line step value*  The line number increment on the converted classic code.  `Default:` `10`  `code:` `self.line_step = [#]`  `.ini:` `line_step = [#]`  `cmdl:` `-lp <#>`    - *Add a header about Basic Dignified*  Add comment lines with information about **MSX Basic Dignified** at the top of the converted code.  	```  	'Converted with Basic Dignified  	'https://github.com/farique1/basic-dignified  	```  	`Default:` `True`  	`code:` `self.rem_header = [True|False]`  	`.ini:` `rem_header = [True|False]`  	`cmdl:` `-rh`  	**SPREAD THE WORD!**    - *Strip spaces*  The conversion will retain spaces around the instructions and variables but some classic Basics don't need them and all non essencial spaces from the code can be removed.  	`Default:` `False`  	`code:` `self.strip_spaces = [True|False]`  	`.ini:` `strip_spaces = [True|False]`  	`cmdl:` `-ss`    - *Capitalise all*  Dignified code is more legible with lower case characters, but some classic Basics need their instructions in upper case.  All non-literal text can be capitalized for compatibility.  	`Default:` `False`  	`code:` `self.capitalise_all= [True|False]`  	`.ini:` `capitalize_all = [True|False]`  	`cmdl:` `-ca`    - *Translate special ASCII characters*  Translate a special set of modern unicode characters to their classic ASCII counterparts.  	`Default:` `False`  	`code:` `self.translate = [True|False]`  	`.ini:` `translate = [True|False]`  	`cmdl:` `-tr`    - *Convert `PRINT` or `?`*  Some classic Basics can use the shorthand `?` in place of `PRINT`.  They can be converted from one to the other. `p` convert all prints to `print` and `?` will convert them to `?`.  	`Default:` **none**  	`code:` `self.convert_print = ['p'|'?']`  	`.ini:` `convert_print = [p|?]`  	`cmdl:` `-cp <p|?>`    - *Strip adjacent `THEN`/`ELSE` or `GOTO`s*  MSX Basic doesn't need both `THEN` or `ELSE` and `GOTO` if they are adjacent. The converted code can be told to strip `THEN`/`ELSE` or `GOTO` if it's the case. `t` strips all possible `THEN`/`ELSE` and `g` strips all possible `GOTO`s.  	`Default:` **none**  	`code:` `self.strip_then_goto = ['t'|'g']`  	`.ini:` `strip_then_goto = [t|g]`  	`cmdl:` `-tg <t|g>`    - *Print report*  A series of reports can be generated detailing the conversion process.  Normally these reports are saved as text files, but they can be logged to the console instead.  	`Default:`  `False`  	`code:` `self.print_report = [True|False]`  	`.ini:` `print_report = [True|False]`  	`cmdl:` `-prr`    - *Label report*  The Dignified label names can be added to the end of their lines on comments in the classic code to help debug the program flow.  For instance: `50 IF a$="A" THEN GOTO 10 '>start` means the line `10` is the `{start}` label.  Labels that receive the flow are preceded by an `<` and outgoing labels (on branching instructions) are preceded by an `>`, a loop label exit has an `*` and a `{@}` label is denoted by `>@`. Function definitions and calls also receive the same treatment.  	`Default:`  `False`  	`code:` `self.label_report = [True|False]`  	`.ini:` `label_report = [True|False]`  	`cmdl:` `-lbr`    - *Line report*  Also helping debug the program flow is a report of the line correspondence betwen the Dignified and classic codes.  In te report, `20 - 11` means the line `20` in the classic Basic is the line 11 on the code editor in the Dignified version.  	`Default:`  `False`  	`code:` `self.line_report = [True|False]`  	`.ini:` `line_report = [True|False]`  	`cmdl:` `-lnr`    - *Variables report*  Another debug tool is the variable report. A report that shows the relationship between long named variables and its short named correspondence.  In the report a `zz:char` means the Dignified long named `char` will be converted to the classic short name `zz`.  	`Default:`  `False`  	`code:` `self.var_report = [True|False]`  	`.ini:` `var_report = [True|False]`  	`cmdl:` `-var`    - *Lexer report*  There is also a report of the lexing process where, for instance, `11 | 10 | C_INSTRC | width` means the `width` instruction was converted to the `C_INSTRC` token and is on the line 11, column 10.  	`Default:`  `False`  	`code:` `self.lexer_report = [True|False]`  	`.ini:` `lexer_report = [True|False]`  	`cmdl:` `-lex`    - *Parser report*  And a report of the parsing process where `11 | 10 | C_INSTRC | WIDTH` means the same thing but is parsed after the lexer output so this list is further optimised.  	`Default:`  `False`  	`code:` `self.parser_report = [True|False]`  	`.ini:` `parser_report = [True|False]`  	`cmdl:` `-par`    - *Verbose level*  Set the level of feedback given by the program.   `0` = silent, `1` = +erros, `2` = +warnings, `3` = +headers, `4` = +subheaders, `5` = +itens.  `Default:` `3`  `code:` `self.verbose_level = [#]`  `.ini:` `verbose_level = [#]`  `cmdl:` `-vb <#>`    - *Output Format*  The format of the converted output. The standard output is a classic Basic in ASCII format `a` but  if a tokenizer is present, a binary format `t` can also be exported. Both can be exported with `at`. The ASCII format is always exported but if only the binary is required, the ASCII file will be deleted after the tokenization.  	`Default:` `a`  	`code:` `self.output_format = ['a'|'t'|'at']`  	`.ini:` `output_format = [a|t|at]`  	`cmdl:` `-of <a|t|at>`    - *Export List*  	If the tokenizer supports any kind of tokenization report, that request can be passed along.  	In th case of the included MSX Tokenizer, a list file similar to the ones exported by assemblers with the tokens alongside the ASCII code and some statistics can be exported. The number argument refers to the amunt of bytes shown per line. If no number is given, the default is 16. The maximum is 32.  `Default:` `16`  `code:` `self.export_list = [#]`  `.ini:` `export_list = [#]`  `cmdl:` `-el <#>`    - *Write the `.ini` file*  Rewites the `.ini` file with the current settings.  `Default:` `False`  `code:` **none**  `.ini:` **none**  `cmdl:` `-ini`    - *Use the `.ini` file*  Tells if the `.ini` file settings should be used or ignored, allowing it to be easily disabled without being moved or deleted.  `Default:` `False`  `code:` **none**  `.ini:` `use_ini_file = [True|False]`  `cmdl:` **none**    - *Help*  Help is available via the command line:  `Default:` `False`  `code:` **none**  `.ini:` **none**  `cmdl:` `-h`    ### The settings environments  Basic Dignified **permanent** or **temporary** settings and **behaviours** can be defined in several places, each with its own **priority**.    >For an explanation of the **individual** settings see the section above.    - **The code itself**  The **lowest** level is in the `\Modules\Settings\badig_settings.py` file.  Here the most **basic** behaviour is defined, the true defaults that can be modified by all subsequent methods. This is the **set and forget**, you should not be messing here.  The code section is:    	```     # System     self.system_id = 'msx'     self.system_name = 'MSX'     self.dignified_ext = '.dmx'     self.ascii_ext = '.amx'     self.binary_ext = '.bmx'     self.list_ext = '.lmx'       # User variables     self.file_load = ''     self.file_save = ''       self.line_start = 10     self.line_step = 10     self.rem_header = False     self.strip_spaces = False     self.capitalise_all = True     self.translate = False       self.convert_print = ''     self.strip_then_goto = ''       self.print_report = False     self.label_report = False     self.line_report = False     self.var_report = False     self.lexer_report = False     self.parser_report = False       self.tab_lenght = 4     self.verbose_level = 3     self.output_format = 'a'     self.export_list = 16  	```  - **The .ini file**  The next level in the hierarchy is the `\Modules\Settings\badig.ini` file.  This is where you can enter **semi-permanent** settings, unique behaviour for the current project, maybe. This is the **friendly** place where to set the new defaults. The settings entered here will override the settings on the code.  > If `badig.ini` is not found, a new one will be regenerated and the execution will stop.    	```  	[CONFIGS]  	use_ini_file = True    	source_file =  	destin_file =    	system_id =    	line_start =  	line_step =  	rem_header =  	strip_spaces =  	capitalize_all =  	translate =    	convert_print =  	strip_then_goto =    	print_report =  	label_report =  	var_report =  	line_report =  	lexer_report =  	parser_report =    	tab_lenght =  	verbose_level =  	output_format =  	export_list =  	```  - **The command line arguments**  Additional settings for each **individual** conversion can be passed through arguments on the command line. These arguments will override the previous methods and are useful to **test** different configurations.  	```  	usage: badig.py [input] [output]  					[-id [ID]] [-tl #] [-ls #] [-lp #] [-rh] [-ss] [-ca] [-cp {?,p,P}] [-tg t|g] [-tr]  					[-vb #] [-of ta] [-el [#]]  					[-prr] [-lbr] [-lnr] [-var] [-lex] [-par] [-exe] [-ini]  					[-h]  	```  - **The remtags**  Remtags are special **exclusive rem** lines that are used on the Dignified code itself to **alter** the behaviour of the conversion and execution of the code.  Their main use is to allow for **quick** settings changes if you are using a **build system** but they can also be used on a command line setting and will override them and all the previous settings.  They are commonly used at the start of the Dignified code:  	```ini  	##BB:export_file=  	##BB:convert_only=  	##BB:arguments=    	##BB:override_machine=  	##BB:override_extension=  	##BB:monitor_exec=  	##BB:throttle=  	```  	> You can easily **disable** a remtag by simply **adding a space** between `##` and `BB`, transforming them in a regular **comment**.      - The first **three** are general Dignified remtags:  	`export_file` is a new file and path to **replace** the current destination file and path. Useful to easily test different **versions** of the code without overriding the previous one.  	`convert_only` is used by the build system to **prevent** the code from running on the **emulator** even if it's the current build setting.  	`arguments` is an **alternative** for the **command line** arguments, allowing them to be used on a build setting but they can be used on a command line setting if one prefers.      - The next four are specific for the **MSX module** and the execution of **openMSX** in particular during the build:  	`override_machine` the name of an **alternate** machine for openMSX to override the default one. Useful to easily **debug** the program on other types os MSX.  	`override_extension` the same as machine but for a **disk drive** extension, in case the selected machine does not have one. The extension will be **inserted** on the ***Slot A*** by default but can be inserted in ***Slot B*** by adding `:SlotB` at the end.  	`monitor_exec` Can be `True` or `False`. Will **monitor** the execution of the program on openMSX. Will catch **errors** on the classic code and **report** them on the corresponding **line** on the Dignified code.  	`throttle` Can be `True` or `False` and force the emulator to open with or without the **throttle** activated.    <!--stackedit_data:  eyJoaXN0b3J5IjpbMTI3NjcxOTgyLDg5NzU1NzE2MiwxNzcwNT  QwMjQwLC0xODY4MjEzNjM5LDE3NzA1NDAyNDAsLTE4NjgyMTM2  MzksMTc3MDU0MDI0MCwxNzcwNTQwMjQwLC0xMDQ3NjQwMzg2LC  0xOTk4NDY1MjE3LC02MTkxOTg3MjYsLTE2OTIzNTcxODYsODE5  NTgyMzE4LC04ODk3Njk2NjEsLTIxMDc4MDAxNzYsMTk0NjQ5OT  Y3NCwzODg5NjIxMTksLTE4ODk4ODI2MTEsMTUwNzE3MzgyMiwt  MjU2NzMzMTE2XX0=  -->  